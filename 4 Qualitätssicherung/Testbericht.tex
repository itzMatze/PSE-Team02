\documentclass[a4paper]{scrreprt}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

\usepackage[german]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{ae}
\usepackage{graphicx}
\usepackage{lscape} % querformat
\usepackage{tabu}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage[toc]{glossaries}
\usepackage{pgfplots}
\usepackage{float}
\makeglossaries

\newglossaryentry{Unittest}
{
  name=Unittest,
  description={Auch bekannt als Modul- oder Komponententest. Wird in der Softwareentwicklung angewendet, um die funktionalen Einzelteile (Units) von Computerprogrammen zu testen, d. h., sie auf korrekte Funktionalität zu prüfen}
}

\newglossaryentry{Hallway Usability Test}
{
  name=Hallway Usability Test,
  description={Test, bei dem zufällige Personen zum Testen von Softwareprodukten und -schnittstellen verwendet werden}
}

\newglossaryentry{Qualitaetssicherung}
{
  name=Qualitätssicherung,
  description={Letzte Phase des Wasserfallmodells}
}


\begin{document}
\title{Testbericht}
\author{Fangzhou Bian, Kathrin Blum, Matthias Bruns, \\Leonhard Duda, Tan Grumser, Yuguang Lin}
\maketitle
%\Footnote für Fußnoten
% Platzierung des Inhaltsverzeichnisses
\tableofcontents



\chapter{Einleitung}

Dieses Dokument verschafft einen Überblick über die \Gls{Qualitaetssicherung} des Projekts. In dieser Phase wurde die Überdeckung der \Gls{Unittest}s maximiert, die Testszenarien des Pflichtenhefts durchgegangen und gefundene Fehler behoben. Des Weiteren wurde ein \Gls{Hallway Usability Test} durchgeführt. Die dokumentierten Tests wurden wieder unterteilt in einen Server- und Clientteil.

\chapter{Server}

\section{Bug Fixes}

\begin{itemize}
\item Sceduler\\ \\
Symptom: Die Funktionen die einmal täglich aufgerufen werden sollten, wurden nicht ausgeführt. TimeController.deleteGroups() und TimeController.updateMensaData() wurden nicht aufgerufen.\\ \\
Ursache: Die Annotationen @Component hat in der Klasse TimeController hat gefehlt, damit hat SpringBoot die Klasse nicht gefunden und den Sceduler nicht Initialisiert.\\ \\
Behebung:  Die Annotation wurde hinzugefügt.
\end{itemize}


\section{Unittests}
Für die Unit Tests wurde das Framework JUnit verwendet. Die Testabdeckung am Server wurde mit EclEmma überprüft.

\begin{itemize}

\item GroupController - Test
getestete Funktionalitäten, zusätzlich zu den bisherigen aus letztem Dokument
\begin{itemize}


\item getGroupByPreferecne
Test: Zwei Testgruppen wurden dem Repository hinzugefügt jeweils mit der selben meetingTime, aber unterschiedlichen Essenslinien
Dann wurde die Methode getGroupByPreference mit Start und Endzeit, sodass beide Gruppen sie erfüllen und einem Array aus Essenslinien, von denen es nur eine Übereinstimmung mit den Gruppen gibt, aufgerufen.
Da GetGroupByPreference sowohl die angegebenen Zeiten, als auch die Essenslinien berücksichtigt, dürfte nur eine Gruppe zurückgegeben werden.
zum überprüfen würde die Länge des zurückgegebenen Arrays überprüft.
\\ \\
Test2: Analog zu oben, nur dass keine Gruppe eine übereinstimmende Essenslinie mit den Preferenzen hatte.
Ziel war es zu sehen, ob ein Array der Länge 0 zurückgegeben wird oder unerwartetes Verhalten auftritt.
Wie erwartet hatte das zurückgegebene Array die Länge null.
\\ \\
Test3: Analog zu oben, gruppen haben passende Essenslinie aber nur eine Gruppe hat eine passende (Rand) Uhrzeit, und wie erwartet wird genau diese Gruppe zurückgegeben.
\end{itemize}

\item UserController - Test 
getestete Funkitonalitäten zusätzlich zu denen aus letztem Dokument

\begin{itemize}

\item DeleteUser
Test 1: Ein User ("User1") wurde anhand seines Tokens ins Repository hinzugefügt. Nun wird versucht einen anderen User ("User2"), der nicht im Repository liegt, aus dem Repository zu löschen. Wie erwartet, wird dabei kein anderer User gelöscht, sondern eine ResponseStatusException geworfen.

\item DeleteAllUser
Test1: Zwei User werden ins Repository hinzugefügt. Danach wird DeleteAllUser aufgerufen, nun sollte kein User mehr im Repository liegen. Beim Versuch auf einen der User mit der Methode "User getUser(String token)" aus dem Repository zu holen, wird eine ResponseStatusException geworfen. 

\item IntitalizeAdminUser
Test 1: Die Methode intializeAdminUser wird aufgerufen, da es noch keinen AdminUser gibt, wird einer neu angelegt. Um das zu überprüfen, prüfen wir, dass das angelegte Userobjekt nicht leer ist.

Test 2: Die Methode initalizeAdminUser wird zweimal aufgerufen. Beim ersten Aufruf wird ein Admin User angelegt, beim zweiten Aufruf sollte nichts passieren, da bereits ein Admin User existiert. 
\end{itemize}
\end{itemize}

\section{Testszenarien}

Die nachfolgenden Tests laufen ausschließlich auf dem Server und sind dazu da die klassenübergreifende Funktionalitäten zu testen.\\


\begin{itemize}

\item Szenario 1 (MK60, MK 80, MK100)\\
Vorbedingung: Es ist bereits User Alice im UserRepository. Dieser User ist in keiner Gruppe.\\
Ablauf: Der User erstellt eine Gruppe und verlässt sie anschließend wieder.\\
Nachbedingung: Der User ist in keiner Gruppe und die erstellte Gruppe hat sich gelöscht, als Alice, als letzter User ausgetreten ist.\\


\item Szenario 2 (MK70, MK 80)\\
Vorbedingung: Es existieren die User A,B und C. Es existiert eine Gruppe X die mit User A und B voll ist. \\
Ablauf: User B verlässt die Gruppe, sodass Platz für User C frei wird. Dieser tritt dann der Gruppe bei.\\
Nachbedingung: User A und C sind in Gruppe X und User B ist in keiner Gruppe.\\


\item Szenario 3 (MK 100)\\
Vorbedingung: Es existiert ein User A der in der Gruppe X ist.\\
Ablauf: Es werden (um Mitternacht) alle Gruppen gelöscht.\\
Nachbedingung: User A  ist in keiner Gruppe und die Gruppe X existiert nicht mehr.\\

\item Szenario 4 (MK110)\\
Vorbedingung: Es existiert ein User A der in der Gruppe X ist und ein Admin User.\\
Ablauf: Die Gruppe X wird von dem Admin User gelöscht.\\
Nachbedingung: User A  ist in keiner Gruppe und die Gruppe X existiert nicht mehr.\\


\end{itemize}

\chapter{Client}

\section{Allgemeines zum Testen und Verbessern}

Die meisten Fehler wurden bereits beim „Ausprobieren“ der App bemerkt und mit dem Debugger lokalisiert, sodass passende Verbesserungen durchgeführt werden konnten. Durch Unit- und Integration-Tests wurden kaum noch Fehler gefunden, dafür aber Funktionalität der Verbesserungen abgesichert. Im Folgenden sind daher die Funktionalitäten der wichtigsten Klassen nach den Verbesserungen und dazu jeweils die diese absichernden Tests aufgelistet. Anschließend werden die Ergänzungen und Veränderungen seit der letzten Phase aufgezeigt und die Motivation dahinter, soweit nicht noch beschrieben, erklärt.
Für die Unit-Tests reichte die in Android-Studio standardmäßig installierte Software nicht aus. Grund dafür ist, dass diese Testsoftware zu viele verwendete komplexere Klassen stubt und mockt, um die Tests schneller und unabhängiger zu machen. Eine Klasse wie Pair<String, State>, die essentiell für die Kommunikation zwischen ViewModel und Activity ist, wird bei den Tests durch einen leeren Stub ersetzt, der das Testen unmöglich macht. Daher mussten weitere Frameworks benutzt werden.

\section{Tools zum Testen}

\subsection{Robolectric}
Robolectric ist ein Framework für Tests in Android Studio, das in Sachen Stubbing und Mocking von verwendeten Klassen geschickter vorgeht als der Standard in Android Studio. Klassen wie Pair werden nicht gestubt, sodass deren Funktionalität gewährleistet ist und sinnvolles Testen möglich wird. Daher wurde dieses Framework installiert.

\subsection{Mockito und Powermockito}
Bei Unit-Tests ist die Überschaubarkeit des Testbereichs wichtig, daher müssen Klassen und Funktionen, die zu weit aus dem Testbereich hinausführen, gemockt werden, wozu sich Mockito eignet. Was Mockito jedoch nicht kann, ist unter anderem, statische Klassen und Methoden zu mocken. Diese werden in MensaMeet bei Serveranfragen verwendet. Abhilfe schafft hier die Erweiterung Powermockito.

\subsection{Espresso}

\section{Models}
\subsection{IdEnum}
Das Interface IdEnum wurde neu eingeführt, um die Umwandlung von Enums mit Konstante-String-Paaren wie Gender, Status und Subject in SpinnerItem-Objekte für die Darstellung in Spinnern (Auswahllisten) zu erleichtern. Zuvor wurde nicht mit Wertepaaren gearbeitet (siehe MensaMeetItem -> E \& V -> Handhabung von Wertepaaren mit representedValues und SpinnerItem), was problematisch war. Die obengenannten Enums und MealLines implementieren dieses Interface.

\subsection{MensaMeetSession}
Dies ist das Singleton, das alle wichtigen activityübergreifenden Daten einer Sitzung wie den aktuellen Benutzer und seine Linienauswahl speichert. \\
\textbf{Elemente (Auswahl)}

\begin{itemize}
\item Attribut user \\
Dies ist der aktuelle Benutzer. Es ist genau dann null, wenn kein Benutzer eingeloggt ist, und kann in diesem Sinne abgefragt werden. Die Gruppe, der der Benutzer beigetreten ist, wird in dessen Attribut groupToken spezifiziert.
\item Methode userDataIncomplete \\
Sie gibt an, ob die Profildaten des aktuellen Benutzers noch nicht ausreichend spezifiziert sind, also ob eine der obligatorischen Angaben Name und Status noch fehlt.
\item Attribut createdGroup \\
Hier wird der Gruppenentwurf des Benutzers nach dem Verlassen von CreateGroupActivity gespeichert, auch wenn er unvollständig ist, damit der Benutzer ihn zu einem späteren Zeitpunkt weiter bearbeiten kann.
\item Methode createdGroupDataIncomplete \\
Sie überprüft, ob die Angaben des Gruppenentwurfs vollständig sind, sodass sie zum Server geschickt werden kann.
\item Methode initialize \\
Mit ihr werden die Daten in MensaMeetSession zu Beginn einer Sitzung initialisiert. Die meisten Daten werden auf null gesetzt, der Parameter user als user gesetzt, der Speiseplan vom Server geladen.
\item Methode invalidate \\
Das Gegenstück zu initialize, dass am Ende einer Sitzung alle Daten auf null setzt.
\end{itemize}

\textbf{Ergänzungen und Verbesserungen seit der letzten Phase}

\begin{itemize}
\item Verzicht auf Attribut chosenGroup \\
Die vom Benutzer ausgewählte Gruppe wird nur noch als groupToken in seiner Klasse spezifiziert. Es ist nicht sinnvoll, das ganze Group-Objekt zu speichern, da es sich ständig durch neue Mitglieder oder durch Löschung verändern kann. 
\item Verzicht auf Attribut receivedGroup \\
Zuvor wurden die passenden Gruppen, die bei SelectGroupActivity vom Server geladen werden, in der Session-Datei gespeichert. Dies ist jedoch nicht nötig, da sie außer in SelectGroupActivity nirgends mehr gebraucht werden.
\item createdGroupDataIncomplete hinzugefügt
\item initialize und invalidate hinzugefügt \\
Dadurch werden Ein- und Ausloggen standardisiert.
\item Prinzip “Kein aktuelles User-Objekt, keine Sitzung“ \\
Scheitert das Anfordern des User-Objekts für den aktuellen Benutzer vom Server, so wird die Sitzung sofort beendet. Zum einen kann es immer sein, dass der aktuelle Benutzer zwischenzeitlich gelöscht wurde, zum anderen ist sind ohne aktuelles User-Objekt keine sinnvollen Aktionen in der App mehr möglich. Der Benutzer müsste versuchen, sich neu einzuloggen.

\end{itemize}

\section{Util-Klassen}

\subsection{HTTPUtil}
Die Klasse HTTPUtil dient zur Kommunikation mit dem Server. Ihre Methoden entsprechen größtenteils bekannten Standard-Beispielen. \\
\textbf{Ergänzungen und Verbesserungen seit der letzten Phase} \\
\begin{itemize}
\item Weiterleitung der Serverantwort auch bei Fehler \\
Die bisherige Implementation der Methode fetch lieferte nur die Serverantwort als JSON-String, wenn kein Fehler vorlag. Ansonsten wurde eine Exception geworfen und die Methode ohne lesen der Serverantwort beendet. Es war jedoch wünschenswert, den genauen Fehlercode und die Fehlermeldung in der App auswerten und gegebenenfalls an den Benutzer weiterleiten zu können. Daher würde die Methode dahingehend verändert, dass sie im Fehlerfall keine Exception, dafür aber den JSON-String der Serverantwort, der Fehlercode und -meldung weitergibt.
\end{itemize}

\subsection{RequestUtil}
Die Methoden der Klasse RequestUtil entsprechend den Diensten, die der MensaMeet-Server anbietet. Sie akzeptieren Objekte der Klassen, die verarbeitet werden sollen, serialisieren sie zu JSON und führen mit Hilfe von HTTPUtil die konkreten Serveranfragen durch. Die JSON-Antwort wird dann wieder zu den jeweiligen Objekten deserialisiert und an den Aufrufer der Methode zurückgegeben. \\

\textbf{Elemente} \\

\begin{itemize}
\item Methode createUser
\item \textit{util.RequestUtilTest.userTest()}
\item Methode getUser
\item \textit{util.RequestUtilTest.userTest()}
\item Methode updateUser
\item \textit{util.RequestUtilTest.userTest()}
\item Methode deleteUser
\item \textit{util.RequestUtilTest.tearDown()}
\item Methode createGroup
\item \textit{util.RequestUtilTest.groupTest()}
\item Methode getGroup
\item \textit{util.RequestUtilTest.groupTest()}
\item Methode getGroupByPrefferences
\item \textit{util.RequestUtilTest.groupTest()}
\item Methode deleteGroup
\item \textit{util.RequestUtilTest.groupTest()}
\item Methode addUserToGroup
\item \textit{util.RequestUtilTest.groupTest()}
\item Methode removeUserFromGroup
\item \textit{util.RequestUtilTest.groupTest()}
\item Methode getMensaData
\item \textit{util.RequestUtilTest.mensaDataTest()}
\item Klasse GroupForRequest \\
\textit{Diese Klasse ist nötig, da sich die Group-Klasse, die vom Server verlangt wird, von der im Client unterscheidet. Im Client sind die Zeiten zur als Date-Objekte, beim Server als Strings hinterlegt. Der Konstruktor und die Methode parseToGroup dienen zur Umwandlung.}
\item Klasse GroupForRequestWithToken \\
\textit{Diese Klasse ist nötig, da beim Erstellen einer neuen Klasse ein Group-Objekt ohne das Attribut token an den Server übertragen muss, um von diesem ein Group-Objekt mit servergeneriertem Token zu erhalten. Diese Klasse enthält token, die Klasse GroupForRequest nicht.   }
\item Klasse GroupWithPrefferences \\
\textit{Diese Klasse entspricht dem JSON-Objekt, das bei einer Anfrage in getGroupByPrefferences dem Server übermittelt wird.}
\item Klasse RequestException
\textit{Diese Exception dient dazu, den Aufrufer einer Methode von RequestUtil bei einem vom Server verursachten oder sonstigen Fehler zu benachrichtigen und ihm Informationen zum Fehler zu übergeben. Ein Konstruktor liest aus dem aus der Serverantwort erzeugten JsonNode Fehlercode- und Fehlernachricht und speichert sie. Liegt kein Serverfehler vor, werden die Daten von eventuell auftretenden anderen Exceptions weitergeleitet. } \\

\textbf{Ergänzungen und Verbesserungen seit der letzten Phase}

\item GroupForRequestWithToken \\
\textit{Zuvor wurden keine servergenerieten tokens vom Server empfangen, da immer ein Group-Objekt mit Attribut token gesendet und dieses vom Server übernommen wurde. Ein servergeneriertes Token ist jedoch notwendig für die eindeutige Identifizierbarkeit einer erstellten Gruppe. }
\item Weiterleitung von Server- und anderen Exceptions \\
\textit{Zuvor konnte man einen Fehler nur erkennen, wenn das von einer Methode in RequestUtil zurückgegebene Objekt nicht den Erwartungen entsprach. Dies war jedoch nicht eindeutig und aussagekräftig.}

\end{itemize}





\subsection{Testszenarien}

Die nachfolgenden Tests laufen auf dem Client und sind zur Überprüfung der korrekten Zusammenarbeit von mehreren Komponenten auf Server und Client.

\begin{itemize}

\item User Registrieren/Anmelden
\item User Profil ändern und wieder lesen.
\item Mensalinien auswählen, Zeit festlegen und Gruppen anzeigen lassen.
\item Gruppe erstellen und anzeigen lassen. Gruppe verlassen.
\item Nach Gruppen suchen und einer beitreten.
\item Nach Gruppen suchen und User in der Gruppe anzeige lassen.
\item Admin User: Gruppen suchen und eine gefundene Gruppe löschen.
\item Admin User: Gruppen suchen und einen User in einer gefundenen Gruppe löschen.


\end{itemize}


\chapter{Hallway Usability Testing}

\section{Einleitung}
TODO: Was sind Hallway Tests, wozu sind sie gut. \\

Aussage von Jakob Nielsen (gilt als einer der führenden Persönlichkeiten auf dem Gebiet Benutzerfreundlichkeit, Gründer der Beratungsfirme Nielson Norman Group für Gebrauchstauglichkeit): Mit 5 Probanden lassen sich bereits 85 \% der Usability Probleme finden.

TODO Quelle in Fußnote
Quelle:  https://www.nngroup.com/articles/why-you-only-need-to-test-with-5-users/ 
\begin{figure}[ht]
	\centering
  \includegraphics[scale=0.5]{Stichprobe.jpg}
	\caption{Stichprobengröße für Usability Tests}
	\label{fig2}
\end{figure}
\newpage
\section{Vorbereitung}
Für uns war es besonders wichtig zu sehen, ob Probanden die für sie unbekannte App, mühelos bedienen können und problemlos die vorgegebenen Ziele erreichen können.
Generelles Feedback, z.b. der Wunsch nach weiteren Funktionalitäten, war im Hinblick auf eine eventuelle Veröffentlichung der Applikation ebenfalls interessant für uns. \\
Unter diesen Gesichtspunkten haben wir folgendne Fragebogen (Abbilding 5.2) zusammengestellt, den die Probanden, nach Durchführung von festgelegten Aufgaben(Listing 5.1.), ausfüllen durften.\\
Um sicherzustellen, dass unsere Aufgaben und Befragung nicht zu viel Zeit in Anspruch nehmen, haben wir es vorher selbst durchgespielt und uns dabei bewusst Zeit gelassen.



\subsubsection*{Listing 5.1. Aufgabenliste}
\begin{itemize}
	\item 1.) Bearbeite dein Profil: Ändere den Namen und das Profilbild
	\item 2.) Plane zwischen 12 und 14 Uhr an der Cafeteria Essen zu gehen
	\item 3.) Trete einer Gruppe bei
	\item 4.) Schau dir das Profil eines Gruppenmitgliedes an
	\item 5.) Verlasse die Gruppe
	\item 6.) Erstelle eine eigene Gruppe
\end{itemize}
\newpage
\begin{figure}[H]
	\centering
  \includegraphics[scale=0.7]{Umfrage.pdf}
	\caption{Evaluationsbogen}
	\label{fig2}
\end{figure}
\newpage

\section{Durchführung}
Es wurden Personen auf dem KIT Campus, welche im Forum saßen, folgendermaßen angesprochen: \\
\ \\
\textit{Hallo, dürfen wir euch eine Frage stellen? Esst ihr regelmäßig in der Mensa?} \\ 
\ \\
Personen die diese Frage bejahten kamen als Probanden in Frage. \\
\ \\
\textit{Würdet ihr an einer kleinen Umfrage teilnehmen, es dauert nur 5 Minuten und als Dankeschön bekommt ihr ein paar Schoko Bons.}  \\ 
\ \\
Bei Zusage wurde eine Person aus der Personengruppe ausgewählt.\\
\ \\
\textit{Also, wir haben eine App entwickelt, mit der sich Leute anonym mit Fremden zum Essen gehen an der Mensa verabreden können und wir wollten uns etwas Feedback dazu einholen, deshalb darfst du die App jetzt kurz für uns testen. Du kriegst gleich ein Handy von uns, auf dem ist bereits ein User registriert und eingeloggt und dann musst du einfach diese sechs Aufgaben(zeigt Aufgabenliste) abarbeiten.} \\
\ \\
Während der Durchführung achteten wir auf die Zeit, schauten aufmerksam zu und notierten uns hinterher unsere Beobachtungen, die im Abschnitt Ergebnisse aufgeführt sind. \\
Nachdem die Aufgaben durchgeführt wurden erhielten die Probanden den Evaluatiosbogen.\\
\ \\
\textit{So, du hast jetzt während den Aufgaben alle Funktionalitäten der App kennen gelernt, jetzt musst du nur noch diesen Umfragebogen ausfüllen und dann bist du fertig.}

\newpage
\section{Ergebnisse}
Unser Test umfasste sieben Probanden, die alle auf oben beschriebene Weise am Campus angesprochen wurden.

\subsection*{Beobachtungen}
Die Probanden benötigten jeweils 5-7 Minuten für den gesamten Test, ab dem Zeitpunkt, ab dem sie das Handy und die Aufgabenliste bekamen. Hauptsächlich nahmen sie sich unterschiedlich viel Zeit für den Fragebogen.\\
\ \\
Zwei Probanden speicherten ihre Profiländerung nicht über den Speichern-Button sondern drückten stattdessen auf Zurück  um wieder in das Home Menü zu gelangen.
\ \\
Sechs von sieben Probanden haben nicht gemerkt, dass nicht nur drei sondern sechs Proflbilder zur Wahl standen.
\ \\
Beim Erstellen einer Gruppe ist die maximale Mitgliederzahl auf 1 einstellbar. 

\subsection*{Auswertung der Evaluationsbögen}
\ \\
\begin{tikzpicture}\begin{axis}[width=1.1\textwidth,height=0.6\textwidth,ybar,enlargelimits=0.1,symbolic x coords={Trifft nicht zu, Trifft eher nicht zu, Neutral, Trifft eher zu, Trifft voll zu}
,xtick={Trifft nicht zu, Trifft eher nicht zu, Neutral, Trifft eher zu, Trifft voll zu}, ylabel={Anzahl Antworten}]

\addplot[color=blue] coordinates{(Trifft nicht zu,0) (Trifft eher nicht zu,0) (Neutral,0) (Trifft eher zu,2) (Trifft voll zu,5)};
\addplot[color=red] coordinates{(Trifft nicht zu,1) (Trifft eher nicht zu,2) (Neutral,1) (Trifft eher zu,1) (Trifft voll zu,2)};
\addplot[color=green] coordinates{(Trifft nicht zu,0) (Trifft eher nicht zu,0) (Neutral,0) (Trifft eher zu,1) (Trifft voll zu,6)};

\end{axis} 
\end{tikzpicture}
\ \\
Legende: \ \\
Blau: Die App war intuitiv/leicht bedienbar. \\
Rot:  Ich würde diese App selber benutzen/weiterempfehlen. \\
Grün: Das Design hat mir gefallen.

\newpage
\subsection*{Antworten in den Freitextfeldern}

\subsubsection*{Wünscht du dir noch weitere Funktionen?}
Vier von sieben Probanden füllten dieses Feld aus: \\
\ \\
- Hashtags für die Gruppen zum Suchen \\
- Bewertungssystem für das Essen \\
- Aktualisieren des Essenplans, wenn etwas ausgegangen ist \\ 
- Bewerten von Essen und Personen \\
- Chat innerhalb der Gruppe

\subsubsection*{Was hat dir gefallen, was hat dir nicht gefallen?}
Zwei von sieben Probanden füllten dieses Feld aus: \\
\ \\
- Einfache Bedienbarkeit, Gute Funktionalität und vorrausschauendes Texting \\
- Hübsches Design \\
\ \\
\subsection*{Fazit}

TODO


\printglossaries
\end{document}